---
title: 调试 main 函数
---

`entry.S` 的任务：开启大页模式、设置栈寄存器 `%esp`，然后通过设置 `%eip` 进入了 `main()` 函数。

所以我们这节将开始调试 `main` 函数，将追踪 XV6 是如何初始化各种资源的。像前面几节一样进入调试，然后将断点打开 `main` 入口。

```bash
(gdb) b main
Breakpoint 1 at 0x80102eb0: file main.c, line 19.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0x80102eb0 <main>:	lea    0x4(%esp),%ecx

Thread 1 hit Breakpoint 1, main () at main.c:19
19	{
(gdb) l
14	// Bootstrap processor starts running C code here.
15	// Allocate a real stack and switch to it, first
16	// doing some setup required for memory allocator to work.
17	int
18	main(void)
19	{
20	  kinit1(end, P2V(4*1024*1024)); // phys page allocator
21	  kvmalloc();      // kernel page table
22	  mpinit();        // detect other processors
23	  lapicinit();     // interrupt controller
```

我们可以看到，`main` 的逻辑地址是 `0x80102eb0`，系统运行在 `i386` 架构上，`main` 函数位于 `main.c` 的第 19 行。

## 1. 初始化内存

`main` 函数一开始就调用了 `kinit1` 函数，收集空闲物理页帧，用于之后的页表分配。进入函数查看一下：

```bash
(gdb) s
=> 0x80102ebf <main+15>:	sub    $0x8,%esp
main () at main.c:20
20	  kinit1(end, P2V(4*1024*1024)); // phys page allocator
(gdb) s
=> 0x80102405 <kinit1+5>:	mov    0xc(%ebp),%esi
kinit1 (vstart=0x801154a8, vend=0x80400000) at kalloc.c:33
33	{
```

`kinit1` 收集的是 `0x1154a8`~`0x400000` 的空闲页帧，此时虽然是大页模式，但是收集页帧的单位已经是 4 K 了，这里的 end 是 kernel 的结束位置，也就是说物理内存中 `0x100000` ~ end 已经被内核使用，而 end ~ `0x400000` 依旧是空闲内存。

这里的 end 是由链接器定义的，从 ELF 中加载进来的，所以这里使用的是声明 `extern`。接着往下看

```bash
(gdb) n
=> 0x80102408 <kinit1+8>:	sub    $0x8,%esp
34	  initlock(&kmem.lock, "kmem");
(gdb) n
=> 0x8010241a <kinit1+26>:	mov    0x8(%ebp),%eax
36	  freerange(vstart, vend);
```

为了管理内存，这里使用到了 `kmem` 结构体，由于内存是共享资源（临界资源），所以提供了自旋锁实现互斥，一开始 `kmem.use_lock = 0`（这里没有显示，是因为编译的时候会打乱一些指令的顺序，这涉及到流水线的知识），因为处理器上只有进程也就是内核本身，所以不需要互斥锁。

紧接着就调用 `freerange` 函数回收 `[vstart, vend)` 的内存。

`freerange` 函数其实就是对每一页帧调用 `kfree` 回收罢了。因此 `main` 的第一个函数分析完毕。

## 2. 内核页表初始化

在调用 `kinit1` 函数的时候，内核还是使用大页模式，用的是 `entry.S` 中定义的简易的页表 `entrypgdir[]`，此时查看 `%cr3` 的值即可找到 `entrypgdir[]` 的物理地址。在 QEMU 调试器下查看 `CR3=00109000`，说明页表 `entrypgdir[]` 就在该物理地址处。

我们看 `kvmalloc` 函数是如何设置内核页表的。打断点进入该函数：

```bash
(gdb) b kvmalloc
Breakpoint 2 at 0x80106ca0: file vm.c, line 142.
(gdb) c
Continuing.
=> 0x80106ca0 <kvmalloc>:	push   %ebp

Thread 1 hit Breakpoint 2, kvmalloc () at vm.c:142
142	{
(gdb) s
=> 0x80106ca6 <kvmalloc+6>:	call   0x80106c20 <setupkvm>
143	  kpgdir = setupkvm();
```

函数使用了一个指针 `kpgdir` 指向 `setupkvm` 函数的返回值， `setupkvm` 函数从 `kmem` 链表中摘取一页物理页帧作为页表，首先将该页帧初始化为全 0。然后根据 `kmap` 的布局对页表进行设置。

`kmap` 结构体的定义如下：

```bash
// This table defines the kernel's mappings, which are present in
// every process's page table.
static struct kmap {
  void *virt;
  uint phys_start;
  uint phys_end;
  int perm;
} kmap[] = {
 { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
 { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
 { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
 { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
};
```

布局很简单，共有四个主要区，分别是 IO 区、kernel 的代码和只读数据、kernel 的变量和空闲内存、设备区。区域划分如下表，其中 `data` 变量是由 `kernel.ld` 定义的，在 GDB 中用 `p/x data` 查看发现 `data=0x80108000` 

|                | 虚拟起始地址 | 物理起始地址 | 物理结束地址 | 读写权限 |
| -------------- | ------------ | ------------ | ------------ | -------- |
| IO             | 0x80000000   | 0            | 0x100000     | 可写     |
| 代码和只读数据 | 0x80100000   | 0x100000     | 0x108000     | 0        |
| 变量和内存     | 0x80108000   | 0x108000     | 0xE000000    | 可写     |
| 设备区         | 0xFE000000   | 0xFE000000   | 0xFFFFFFFF   | 可写     |

