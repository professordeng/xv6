---
title: 6. 系统内核主体代码
date: 2019-04-11
---

前面我们已经了解到 `xv6` 系统包括启动引导代码、内核主体、磁盘文件系统中的应用程序三个组成部分。这一小节则是对内核主体代码的一个简要介绍。按照操作系统功能，我们按照进程管理、内存管理、文件系统和设备四个方面展开。

## 1. 进程管理

`xv6` 是分时多任务操作系统，与任何其他分时多任务操作系统一样，进程都是其核心概念。`xv6` 通过 `PCB` 进程控制块管理进程，`xv6` 的进程控制块是一个 `proc` 结构体。所有的进程控制块构成一个静态的数组 `ptable[NPROC]`（`NPROC` = 64），未使用的进程控制块其状态设置为未使用（`ptable[X].state` = `UNUSED`）。`xv6` 进程控制块在进程亲缘关系方面只记录父进程，并不像 `Linux` 那样还记录子进程、兄弟进程的关系。进程控制块 `proc` 中记录的进程资源主要是该进程所打开的文件、页表、内核栈等少量信息。

从这里可以看出 `xv6` 仅可以作为教学系统，虽然 “麻雀虽小五脏俱全”，但是设计和实现上确实非常简陋。

### 1.1 进程调度

由于各个处理器共享一个全局进程表 `ptable[]`，调度算法采用的是简单的时间片轮转算法。各处理器核上的调度器并发地共享一个就绪进程队列，因此需要用自旋锁进行互斥保护。

#### 时间片轮转调度

如果用户程序一直占有 `CPU` 使得 `xv6` 操作系统得不到运行，那么操作系统什么事也做不了。因此计算机上通常设置了定时中断，通过中断转去执行中断服务代码（这些代码属于操作系统内核），因此操作系统才有机会接管系统并进行相关的管理。

定时器每经过一个计时周期 `tick` 就会发出时钟中断，每次都会经时钟中断处理函数进入到调度函数，从而引发一次调度。调度器则是简单地循环扫描 `ptable[]`，找到下一个就绪进程，并且切换过去。

也就是说，`xv6` 的时间片并不是指一个进程每次能执行一个时间片 `tick` 对应的时长，而是不管该进程什么时候开始拥有 `CPU` 的，只要到下一个时钟 `tick` 就必须再次调度。每一遍轮转过程中，各个进程所占有的 `CPU` 时间是不确定的，小于或等于一个时钟 `tick ` 长度。例如某个进程 A 在执行了半个 `tick` 时间然后阻塞睡眠，此时调度器执行另一个就绪进程 B，那么 B 执行半个 `tick` 后就将面临下一次调度。

#### 调度切换时机

除了被动的定时中断原因外，还可能因为进程通过系统调用进入内核，出于某些原因而需要阻塞，从而主动要求切换到其他进程。例如发出磁盘读写操作、或者直接进行 `sleep` 系统调用都可能进入阻塞并且换到其他进程。

#### 执行断点

在继续讨论之前，我们先要澄清一下 “断点” 的概念，根据被中断的代码运行级别，它可能是

1. 用户态断点
2. 内核态断点

根据引发代码断点原因，可以分为

1. 系统调用/中断
2. 代码切换

这些断点根据上述组合，可以出现 4 大类，如表所示

|        | 系统调用/中断                  | 进程切换         |
| ------ | ------------------------------ | ---------------- |
| 用户态 | 进入内核态，断点在 `trapframe` | 无               |
| 内核态 | 保持内核态，断点在 `trapframe` | 断点在 `context` |

- 系统调用/中断引起的断点

  这类断点都是用 `trapframe` 来保存的，如果发生在用户态则在 `trapframe` 中有 `ss` 和 `esp`，而在内核态发生系统调用/中断，则 `trapframe` 中没有保存 `esp` 和 `ss` 的。

  **进程的用户态断点 **：例如 `shell` 进程发出读按键操作的 `read()` 系统调用从而进入内核态，此时 `shell` 的用户态代码断点就是发出 `read()` 系统调用的位置，当从系统调用返回时需要从该位置的下一条指令开始运行。又或者，`shell` 进程在执行某条用户态代码中的指令 `x`，此时发生了时钟中断从而进入内核态执行中断服务程序，那么此时 `shell` 用户态断点就是 `X` 指令处，下次再被调度执行返回到用户态时，需要从该断点处恢复执行 `X+1` 指令。
  
  **进程的内核态断点** ：例如，当进程在执行 `getpid` 系统调用的过程中，发生了一次中断，那么断点在 `getpid()` 函数的某处。此时该断点也是通过一个 `trapframe` 保存在本进程的内核栈中。
  
- 切换代码断点

  该断点仅仅是进程切换的辅助代码中的断点，与进程本身没有关系（既不是系统调用应该执行的代码，也不是中断服务所需要执行的代码）。而仅仅是 `swith()` 切换代码的断点。

  例如，上述 `shell` 进程进入到 `read()` 系统调用的内核态代码后，发现没有按键，则通过 `sleep()` 进入阻塞以等待按键发生，`sleep()` 进一步调用 `sched()` 换到其他进程，此时 `shell` 进程在 `sched()` 中的某处停止运行，该断点称为切换代码的断点。当用户按键之后进程重新成为就绪进程，下次被调度时需要从 `sched()` 处的断点恢复运行，并逐级返回将按键值传给 `shell` 进程。类似地，如果 `shell` 是因为时钟中断而进入内核代码，也存在 `sched()` 某处停止运行的断点，再次被调度时从该断点处继续运行。

**注意** ：我们后面将系统调用/中断引起的断点简称为 “中断断点”，而切换代码断点成为 "切换断点"。

#### 进程切换过程

`xv6` 通过上面的调度机制，实现多个进程在处理器上断续地、轮流地获得执行。我们称让出 CPU 的进程为 “换出进程”，即将获得 CPU 的进程为 “切入进程”，换出和切入两个操作就称为进程切换过程。在 `xv6` 代码中，调度代码相对比较简单，但是进程切换过程的代码则比较复杂。

进程切换总是发生在内核态，在底层实现上分成两个步骤：从换出进程的内核执行流切换到调度器 `scheduler` 的执行流，然后再从调度器 `scheduler` 的执行流切换到切入进程的执行流。

从换出进程 `shell` 切换到切入进程 `cat` 的过程如下：

|         | 流程描述                                          |
| ------- | ------------------------------------------------- |
| 第 1 步 | `shell` 从用户态进入内核态，保存数据到 `kstack`   |
| 第 2 步 | 执行 `swtch` 函数切换到 `scheduler`，执行调度算法 |
| 第 3 步 | `swtch` 到 cat 的核心态，从 `kstack` 中取数据     |
| 第 4 步 | cat 从核心态换到用户态，执行 cat                  |

选择下一个被执行进程的调度操作是通过 `scheduler()` 函数完成，该函数虽然没有独立的进程号，但是具有独立的执行流，拥有独立的用于保存断点现场的堆栈。`scheduler()` 被设计成一个无限循环，其工作就是选取下一个就绪进程，然后切换过去执行。

从上表可以看出，用户进程必须进入到内核态（中断或系统调用）才可能发生切换，也就是说无论是 shell 进程被打断的位置，还是 cat 恢复执行的位置，都是处于某一段内核代码中的。因此进程切换所关心的进程执行 “切换断点” 并不在用户代码处（也就是说此处所谓的执行流的 “断点” 和用户代码没有关系）。当然从切换断点恢复执行后，最终还是要返回到因 “系统调用/中断” 引起的用户态断点或内核态断点的。例如我们这里从 shell 进程的 “切换断点” 恢复执行后，最终还将返回到用户态断点 `read()` 的下一条指令继续运行。

由于存在 “换出进程→内核→切入进程” 执行流的转换，需要解决执行流被打断执行后内核断点的现场保存，以及将新进程从上次内核断点处恢复现场并再次运行的问题。`xv6` 使用堆栈来保存这些现场，这就要求每个进程有自己的独立 “内核栈”，而每个处理器上的 `scheduler()` 内核执行流也要有自己的独立内核栈。同理，用户态断点也需要保存现场，`xv6` 代码借助 `x86` 的硬件中断机制，利用堆栈中的陷阱帧 `trapframe` 保存现场的。

### 1.2 负载均衡

`xv6` 进程管理中只涉及进程的简单调度（多个处理器核共用一个就绪任务队列并按照论循方式进行调度）。也就是说 `xv6` 并没有显式地进行负载均衡（只是在调度中简单地处理负载均衡问题）。
例如两个处理器，各自的调度器从一个公共的 `ptable[]` 中查找就绪进程，并执行该进程一个时间片，然后进入下一个调度周期。因此 `ptable[]` 的任务并不绑定于某个处理器，从而不会出现一个处理器忙而另一个处理器空闲的情况（这就间接地在一定程度上实现了负载均衡）。

## 2. 内存管理

内存管理将分成三个方面来讨论：

1. 启动时的内存管理
2. 空闲物理页帧管理
3. 进程的虚存空间管理

`xv6` 内存管理整体上说比较简单，因此顶层的内存管理代码很容易掌握。但是由于 `x86` 硬件的地址部件复杂性，使得底层与 CPU 地址部件交互的代码显得比较繁杂。

### 2.1 启动时内存管理

`x86` 启动时处于 16 位状态并且没有分页机制，寻址空间为 0~2^20-1（共 1 MB），然后启动扇区的代码将很快进入保护模式将寻址空间扩展到 0~2^32-1（共 4 GB）并开启分段地址模式，内核主体代码运行后则启动分页机制。因此整个启动过程经历了三种不同的地址模式。

需要特别提到的是，虽然 `x86` 处理器设计的很复杂，进入保护模式后既有分段又有分页机制，但是 `xv6` 仅利用 `x86` 的分段机制作特权级控制，使用两个用户段（代码和数据各一个）和两个内核段（代码和数据各一个）。这四个段都设置为从 0 地址开始，因此 `x86` 下的逻辑地址和线性地址是一致的，相当于架空了分段机制的地址映射功能（保留了特权控制能力）。ARM 处理器和 MIPS 处理器只使用分页机制而没有分段机制，相对而言它们的内存管理代码比较简洁。

### 2.2 物理内存管理

启动分页机制后，空闲的物理页帧是按照链表方式管理的。每个空闲物理页帧的头部几个字节用作链接指针，链表头由 `kmem.freelist` 所管理。当需要分配物理页帧时，通过 `kalloc()` 从链表头部取下一个页帧，反之释放一个页帧后通过 `kfree()` 加入到该空闲列表中。

### 2.3 进程空间管理

`xv6` 的进程在启动时的内存空间使用情况由可执行文件中的信息决定，运行后还可能申请新的空间或释放内存空间，呈现动态变化。`xv6` 进程空间的内存管理也比较简单，只是一个连续区间的伸缩变化，而不像 Linux 进程那样会出现多个离散的区间。

## 3. 文件系统

`xv6` 实现了 Unix/Linux 风格的文件系统，虽然功能简单并缺少性能上的考虑，但是能体现出 Unix 文件系统所有的核心概念。可以提供用户数据的保存和管理，实现在 `IDE` 硬盘上的数据持久化（persistence）能力。 

简单说来，`xv6fs` 文件系统和其他文件系统一样，需要解决以下几个问题：

1. 磁盘空间的管理：需要对磁盘盘块按照功能不同进行划分和布局
2. 文件数据盘块的组织：记录一个文件所包含的数据盘块有哪些
3. 按名访问的能力：文件按路径进行访问，形成树状组织关系
4. 文件的读写操作：提供系统调用，用于实现文件的读写操作过程

为了提高性能和可靠性，`xv6` 和通常的文件系统一样，还提供了以下的能力：

- 提供磁盘盘块缓冲：用内存空间充当磁盘数据的缓冲，形成二级存储体系提高访问性能
- 保证数据完整性：在文件写操作中，用日志方式来实现，即便系统崩溃也能保证数据完整性

### 3.1 磁盘布局

`xv6fs` 将整个磁盘进行分割以形成不同用途的区域：

1. 超级块：记录文件系统的整体信息， 包含磁盘空间的布局情况。
2. 索引节点区：每个索引节点记录一个文件的数据盘块位置。
3. 盘块位图区：每一个 bit 表示对应的数据盘块是含有文件数据还是空闲
4. 数据盘块区：用于保存各种 文件数据。
5. 日志区：用于保存写操作的日志。

### 3.2 文件数据盘块组织

一个 `xv6fs` 中的文件用一个索引节点 `inode` 来管理其数据盘块，即混合索引方式。一部分数据的盘块号直接记录在 `inode` 的一个数组成员变量中，可以快速方便地访问到。其余的数据盘块号（如果有的话）记录到一个索引盘块中，需要间接访问才能获得。

### 3.3 目录结构

索引节点虽然管理了一个文件的磁盘盘块，但是文件系统中有众多的文件需要有效管理， 而实践中树形目录结构是常用的有效方式。`xv6fs` 中一个目录记录为一个文件，该文件的数据按照目录项的结构进行解析，每一个项包含一个文件（或子目录）名以及对应的索引节点号。 与 Linux 的 EXT 文件系统类似，根目录 `/` 有固定的位置，`xv6fs` 的根目录对应索引节点为 1 的那个文件。通过目录文件的层次关系，就可以建立起目录的树形结构。

### 3.4 读写操作

文件系统并不只是磁盘上的数据，而且还包含如何访问它们的代码。`xv6fs` 提供了若干文件系统访问的系统调用，包括读写、创建与删除、链接等。这些代码需要根据前面文件系统的存储规范（布局、索引等格式）来获取所需的数据，而且还需要和其他辅助系统互动：

1. 需要 `IDE` 设备驱动来实现具体盘块的读写访问。
2. 需要借助块缓存来加快文件读写操作（对于 Linux 使用的是页缓存）。
3. 需要借助日志来保证写操作的原子性，实现文件数据的完整性。