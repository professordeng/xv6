---
title: 4. 分页机制
---

X86 处理器在进入保护模式之后，仅仅启用分段内存管理机制，分页机制还未开启。 如果启用分页硬件机制并结合软件的换页技术可以实现虚拟内存，从而让进程的编程空间可以大于系统的物理内存。OS 提供虚存管理后，使得多任务执行环境下的应用程序编程者对内存的使用更加简单和有效方便。 

由于 xv6 在启动时使用了 X86 硬件的大页模式，后续运行是采用 4KB 页，因此读者需要对两种模式都有一些认识。 

## 1. 4 KB 模式

在 32 位系统上，两级页表机制，全局页目录 PGD（Page Global Directory）和页目录 PD （Page Directory），保存数据的页和保存页表项的物理页在管理上没有什么本质区别。在 64 位系统上需要经过 4 级页表。 

页表内容由操作系统软件填写，而由地址硬件部件使用。页表虽由处理器地址部件使用，但却保存在 CPU 外部的内存上（近期常用的少量页表项保存在处理器内部的 TLB 中）。 每个进程有自己的全局页目录表 PGD，它通过进程控制块的成员 `mm_struct->pgd` 指针来引用，实际上指向一个物理页帧。这个对应于 PGD 的页帧被看做一个类型为 `pgd_t` 类型的数组，例如 32 位 X86 中 4 KB 页帧包含数组元素有 1024 个，每个元素指向下一级页表（PMD），`pgd_t` 类型定义于 `asm` / `page.h` 文件中且因体系结构而不同。进程切换时通过使用不同的 PGD 实现页表切换，从而让处理器看到相应的新进程空间。X86 结构中是将切入进程的 `mm_struct->pgd` 装入到处理器 CR3 寄存器来实现的。 

PGD 表中的每一项各自指向一个物理页帧，该页帧称为 PMD，包含多个 `pmd_t` 类型的页中间目录 PMD 表项。每个 PMD 项各自指向一个物理页帧，该页帧称为 PD，每个 PD 包含多个 `pte_t` 类型的页表项 PTE（Page Table Entries）。每个 PTE 项通常最终指向一个用于保存数据或代码的物理页帧，当 PTE 无效时需要额外信息指出从磁盘什么位置可以读到该页内容，文件映射页是通过相应 VMA 的 `vm_area_struct->vm_file` 指出所在磁盘文件，而匿名页换出后则在 PTE 中保存换出位置。于是，每一个线性地址都分成几个部分，分别是 PGD 索引号、PMD 索引号、PD 索引号以及页内偏移。 

在 `xv6` 与页表处理相关的代码中，并不区分 PDE 和 PTE，而使用同一个数据类型 `pte`， 读者需要注意区分。 

需要注意线性地址（Linear Address）指的是属于当前处理器上正在运行的进程空间，`mm_struct->pgd` 给出的是物理地址，`pgd_t` / `pmd_t` / `pte_t` 项保存的地址也都是物理地址。运行时操作系统需要为进程设定 `mm_struct->pgd`、将 `mm_struct->pgd` 写入到 CR3 寄存 器以及修改各级页表内容。处理器发出的每一个虚地址访问过程中的地址转换过程都是由硬件完成的。

下面以 X86 系统为例说明虚地址转换成物理地址的过程。在不支持 PAE 的 32 位 X86 机器上使用两层页表。物理页大小为 4 KB，物理内存大小为 2 GB，CR3 寄存器指向第 48 号页帧，最终读入 `xyz` 的值。

1. PDX 宏（116 行）用于取得虚地址的页目录索引值。
2. PTX 宏（119 行）用于获得虚地址的页表索引值。
3. PGADDR

## 2. 大页模式

`xv6` 使用大页模式，每个页有 4 MB，因此程序发出的虚地址（线性地址）被划分成 `10 bit : 22 bit` 两个部分，前面 10 bit 用来做页目录索引，后面用来做页内偏移。因此 `xv6` 只需要使用一级页表既可以完成虚实地址转换，每个页表只需要占用 4 KB 即可。

在页表转换过程中，如果 PGD 项指出是大页，则不需要后续转换。

**CR4 控制寄存器**

