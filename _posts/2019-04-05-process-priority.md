---
title: 2. 优先级调度
date: 2019-08-03
---

接下来在做一个简单的实验，为原来调度（Round Robin）增加优先级，只调度最高优先级进程，如果有多个最高优先级的进程，则这些进程间按照 RR 方式调度。为了实现优先级调度，首先需要在进程控制块中加入优先级成员，然后需要修改调度器的调度算法。当然还需要提供修改和设置优先级的系统调用，如果是动态优先级还需要优先级调整算法等。我们下面来实现 `xv6` 系统上的静态优先级调度。 

本节做一个简单的实验，为原来的时间片轮转调度（Round Robin）增加优先级，只调度最高优先级进程，如果有多个相同最高优先级的进程，则这些进程间按照 RR 方式调度。为了实现优先级调度，我们需要完成

1. 在进程控制块中加入优先级成员，并设置默认值。
2. 提供修改优先级的系统调用。
3. 需要修改调度器的调度算法，这里的优先级是静态的，所以是抢占式静态优先级调度算法。
4. 提供测试样例

## 1. 添加优先级属性

在 `xv6` 的 `proc.h` 中修改 `proc` 结构体（进程控制块），增加成员 `priority`。

既然有了优先级，那么在创建进程的时候就需要指定一个优先级或设置一个默认优先级。我们选择创建时使用默认优先级，后续需要的时候再调整优先级的方案。因此创建进程时分配 `proc` 结构体的 `allocproc()` 需要设置新进程的 `priority` 成员，并将 10 作为普通进程的默认优先级。

在 `exec.c` 切换 `curproc` 之前设置 `curproc->priority` 为 3，也就是说 `exec` 拷贝的进程优先级皆为 3。

为了能查看进程的优先级，我们需要修改 `proc.c` 中的 `procdump()` 函数，使之能打印优先级信息。除了打印进程优先级 `priority` 之外，在格式上也有一点小修改， 使得打印输出的效果更好一点。 

## 2. 设置优先级

既然有基于优先级的调度，那么就需要提供设置优先级的系统调用。由于之前讨论过如何添加新的系统调用，这里只给出简要说明和核心代码。这个新的系统调用起名为 `chpr()`。简要步骤如下：

1. 在 `syscall.h` 中为新的系统调用定义其编号（必须和其他系统调用编号不同）。
2. 在 `user.h` 中增加用户态函数原型 `int chpr(int pid, int priority)` 函数，第一个参数用于指出进程号，第二个参数指出新的优先级。 
3. 在 `usys.S` 中添加 `chpr()` 函数的汇编实现代码（宏展开后对应于 `sys_chpr` 函数）。
4. 修改系统调用的跳转表（`syscall.c` 中的 `syscalls[]` 数组）。
5. 由于 `syscall.c` 中未定义 `sys_chpr` 函数，因此需要在上面这个 `syscalls[]` 数组前面增加一个外部函数声明。
6. 在 `sysproc.c` 中实现 `sys_chpr()`。先获取 `pid` 和 `pr` 两个参数，然后调用 `chpr(pid, pr)` 将编号为 `pid` 的进程优先级设置为 `pr`。
7. `chpr()` 的实现放在 `proc.c` 中。
8. 最后在 `defs.h` 的 `proc.c` 部分添加函数原型 `int chpr(int, int);`，以便内核代码访问该函数。

顺便添加一个 `chpr` 命令来实现在 `shell` 下修改进程的优先级。

## 3. 修改调度器

为进程添加优先级的信息后，还需要在调度器中修改调度行为。我们并没有对进程控制块数组进行改动，而是增加一个 `struct proc *highP` 变量来记录优先级最高的就绪进程。

若出现了多个最高优先级的进程，那么这些进程的调度是 RR 调度。

## 4. 验证优先级调度

首先在 `param.h` 中确认 `NCPU` 的数目为 2，也就是说系统最多可有两个进程同时运行，易于观察。

编写 `prio.c`，生成多个不同优先级的进程，并执行一些任务使其处于 `RUNNABLE` 或 `RUNNING` 状态，用于观察。

`prio` 程序需要三个参数，第二个参数控制生成的子进程数目，第三个参数控制计算的任务量。例如：

```bash
piro 1 2&  # 生成一个子程序，并分配 2 倍的任务给子程序，时间也就延迟 2 倍
```

执行下面指令，后台会有 3 个程序在执行任务。

```bash
make qemu-nox   # 启动系统
prio 2 2&       # 创建进程并在后台执行 
```

然后修改将其中两个程序的优先级设置为 4，可以按 `Ctrl + p` 查看进程的执行状态。发现有三个程序处于 `sleep` 状态，是属于执行 `wait()` 后的父进程。还有两个优先级为 4 的进程处于 `run` 状态，一个优先级为 10 的处于 `runnable` 状态。这说明系统将 CPU 资源都分配给了高优先级的进程。

可以尝试多创建几个进程，观察进程状态。