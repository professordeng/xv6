---
title: 1. 内存管理
date: 2019-05-01
---



`xv6` 通过页表机制实现了对内存空间的控制。页表使得 `xv6` 能够让不同进程各自的地址空间映射到相同的物理内存上，还能够为不同进程的内存提供保护。 除此之外，我们还能够通过使用页表来间接地实现一些特殊功能。`xv6` 主要利用页表来区分多个地址空间，保护内存。另外，它也使用了一些简单的技巧，即把不同地址空间的多段内存映射到同一段物理内存（内核部分），在同一地址空间中多次映射同一段物理内存（用户部分的每一页都会映射到内核部分），以及通过一个没有映射的页保护用户栈。

## 1. 页表机制

在 `x86` 体系下，有三种地址，程序中各种符号地址为虚拟地址，CPU 实际访问的内存地址为物理地址。在 `x86` 体系下：

1. 虚拟地址可分成多段，例如数据段、代码段、动态内存段等等。
2. 每一段在逻辑上是线性的，称为线性地址。
3. 段的存储在实现上使用分页机制，因此物理上段可能是不连续的。

在 `xv6` 中，除了每个 CPU 独立的数据具有非零的段基址外，其余包括内核数据段，内核代码段，用户数据段，用户代码段都是段基址为 0 的描述符，这样大大简化了地址转换操作和程序的编程，因为分段机制是由程序员控制，而分页机制是由操作系统负责的，在 `xv6` 中，虚拟地址可以直接通过分页变换到物理地址。

分页机制是通过页表来进行转换的，具体转换关系如下：

![x86 page table](/xv6-book/img/pageTable.png)

`x86` 所有的虚拟地址都经过页表来完成地址转换，页表由 `cr3` 寄存器指定的物理地址来表示，内存地址转换单元 `mmu` 通过查找页表来确定最后的物理地址，通过给 `cr3` 赋值便能实现不同进程拥有不同的页表，也就是不同进程拥有不同的地址空间。

页表由一级的页目录项和二级的页表项组成，每个页目录项下级有 1024 个连续的页表项（每个页表项 4 Byte，刚好占用 4 K 空间，也就是一页），页目录项同时也是连续的，一共有 1024 个页目录项，由于 32 位系统地址线只有 32 条，所以最高支持 4 G 的地址空间，页目录项也是连续的，所以页目录刚好也占用一页。

每个页目录项和页表项由下一级的物理地址和相关标志位组成，页目录项拥有下一级页表的物理地址，页表项拥有实际物理地址的部分，通过设置权限位可以实现内核和用户进程代码和数据的保护。

具体转换过程如图所示，虚拟地址前十位作为页目录的偏移找到页目录项，找到页表基地址，接下来十位作为页表项的偏移找到页表项，最后将页表项的基址 + 最后 12 位偏移得到实际的物理地址。

## 2. 内存初始化

在初始化 `main()` 函数最开始处，内核代码存在于物理地址低地址的 `0x100000` 处，页表为 `main.c` 中的 [entrypgdir](https://github.com/professordeng/xv6-expansion/blob/master/main.c#L102) 数组，其中虚拟地址低 4 M 映射物理地址低 4 M，虚拟地址 `[KERNBASE, KERNBASE+4MB)` 映射到物理地址 `[0, 4MB)`。可见现在内核实际能用的虚拟空间显然不足以完成正常工作的，所以初始化过程中需要重新设置页表。

 ### 2.1 物理内存初始化

`xv6` 在 `main()` 函数中调用 `kinit1()` 和 `kinit2()` 来初始化物理内存，`kinit1()` 初始化内核末尾到物理内存 4 M 的物理内存空间到物理页帧空闲链表。

```c
kinit1(end, P2V(4*1024*1024)); // phys page allocator
```

`kinit2()` 初始化剩余内核空间到 `PHYSTOP` 到物理页帧空闲链表。

```c
kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
```

两者的区别在于 `kinit1()` 调用前使用的还是最初的页表（也就是上面的内存布局），所以只能初始化 4 M，同时由于后期再构建新页表时也要使用页表转换机制来找到实际存放页表的物理内存空间，这就构成了自举问题，`xv6` 通过在 `main()` 函数最开始处**释放内核末尾到 4 MB 的空间来分配页表**，由于在最开始时多核 CPU 还未启动，所以没有设置锁机制。

`kinit2()` 在内核构建了新页表后，能够完全访问内核的虚拟地址空间，所以在这里初始化所有物理内存，并开始了锁机制保护空闲内存链表。

### 2.2 内核新页表初始化

`main()` 函数通过调用 `kvmalloc()` 函数来实现内核新页表的初始化。通过初始化，内核物理地址 `end` 到物理地址 `PHYSTOP` 的内存空间未使用，虚拟地址空间 `KERNBASE` 以上部分映射到物理内存低地址相应的位置。

![virtual memory layout](/xv6-book/img/vm-layout.png)

## 3. 物理内存管理

`xv6` 对上层提供 `kalloc()` 和 `kfree()` 接口来管理物理内存，上层无需知道具体的细节，具体实现看 [kalloc.c](https://github.com/professordeng/xv6-expansion/blob/master/kalloc.c)。`kalloc()` 返回虚拟地址空间的地址，`kfree()` 以虚拟地址为参数，通过 `kalloc()` 和 `kfree` 能够有效管理物理内存，让上层只需要考虑虚拟地址空间。

`xv6` 通过将未分配的内存构成一个简单的链表来管理物理内存，具体看 [kalloc.c#L20](https://github.com/professordeng/xv6-expansion/blob/master/kalloc.c#L20)。`xv6` 使用了空间内存的前部分作为指针域来指向下一页空闲内存，物理内存管理是以页（4 K）为单位进行分配的。也就是说物理内存空间上空闲的每一页，都有一个指针域（虚拟地址）指向下一个空闲页，最后一个空闲页的指针域为 `NULL`。 
通过这种方式，只需要保存着虚拟地址空间上的 `freelist` 地址即可，`kalloc()` 和 `kfree()` 操作的地址都是虚拟地址，通过页表来完成到物理地址的转换。

通过 `kalloc()` 和 `kfree()`，屏蔽了对物理内存的管理，使得调用者只需要关心虚拟地址空间，在需要使用新内存空间的时候调用 `kalloc()`，在需要释放内存空间的时候调用 `kfree()`。

## 4. 内存管理函数

`xv6` 通过提供几个接口来实现内核页表的控制和用户页表的控制，`xv6` 让每个进程都有独立的页表结构，在切换进程时总是需要切换页表，内核空间切换由 [switchkvm()](https://github.com/professordeng/xv6-expansion/blob/master/vm.c#L147) 实现，用户空间切换由 [switchuvm()](https://github.com/professordeng/xv6-expansion/blob/master/vm.c#L155) 实现。

页表和内核栈都是每个进程独有的，`xv6` 使用结构体 `proc` 将它们统一起来，在进程切换的时候，他们也往往随着进程切换而切换，内核中模拟出了一个内核线程，它独占内核栈和内核页表`kpgdir`，它是所有进程调度的基础。

`switchuvm()` 通过传入的 `proc` 结构负责切换相关的进程独有的数据结构，其中包括 `TSS` 相关的操作，然后将进程特有的页表首地址载入 `cr3` 寄存器，完成设置进程相关的虚拟地址空间环境。

进程的页表在使用前往往需要初始化，其中必须包含内核代码的映射，这样进程在进入内核时便不需要再次切换页表，进程使用虚拟地址空间的低地址部分，高地址部分留给内核，设置页表时通过调用 `setupkvm()`、`allocuvm()`、`deallocuvm()` 接口完成相关操作，均在 `vm.c`。

`setupkvm()` 通过 `kalloc()` 分配一页内存作为页目录，然后将按照 `kmap()` 数据结构映射内核虚拟地址空间到物理地址空间。

`allocuvm()`、`deallocuvm()` 负责完成用户进程的内存空间，`allocuvm()` 在设置页表的同时还会分配物理内存供用户进程使用。这里分配的内存在虚拟空间上是连续的，`xv6` 通过放缩来实现堆的分配和回收。

`vm.c` 文件中提供了 `loaduvm()` 函数将文件系统上的 `i` 节点内容读取载入到相应的地址上，通过`allocuvm()` 函数为用户进程分配内存和设置页表，然后调用 `loaduvm()` 函数将文件系统上的程序载入到内存，便能够为 `exec()` 系统调用提供接口，为用户进程的正式运行做准备。

`vm.c` 中还有一个 `inituvm()` 函数，为第一个进程所使用，通过调用它能够初始化虚拟地址为 0 的 `initcode.S` 的虚拟地址环境，`initcode.S` 是独立于内核编译和链接的，它的加载地址和运行地址都为 0。

当进程销毁需要回收内存时，可以调用 `freevm()` 清除用户进程相关的内存环境，`freevm()` 首先调用 `deallocuvm()` 将 0 到 `KERNBASE` 的虚拟地址空间回收，然后销毁整个进程的页表。

在 `vm.c` 中，`copyuvm()` 负责复制一个新的页表并分配新的内存，新的内存布局和旧的完全一样， `xv6` 使用这个函数作为 `fork` 的底层实现。

在 `vm.c` 的最后，还有两个函数，其中 `uva2ka()` 将一个用户地址转化为内核地址，也就是通过用户地址找到对应的物理地址，然后退出这个物理地址在内核页表中的虚拟地址并返回，`copyout()` 则调用 `uva2ka()` 则拷贝 `p` 地址 `len` 字节到用户地址 `va` 中。

## 5. 总结

`xv6` 对于物理内存的管理较为简单，只是将每一空闲页用链表链接起来，向上提供 `kalloc` 和 `kfree` 接口来屏蔽管理物理内存的细节，`xv6` 将内存管理分为内核地址空间管理和用户地址空间管理，并提供几个函数供系统调用过程调用，很多需要管理内存的系统函数例如 `exec()`，`fork()` 都需要使用到这些接口，`vm.c` 和 `kalloc.c` 包含了内存管理的大部分内容，系统调用过程使用这些函数来初始化和处理页表结构。